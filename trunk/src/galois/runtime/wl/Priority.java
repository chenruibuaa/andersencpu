/*
Galois, a framework to exploit amorphous data-parallelism in irregular
programs.

Copyright (C) 2010, The University of Texas at Austin. All rights reserved.
UNIVERSITY EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES CONCERNING THIS SOFTWARE
AND DOCUMENTATION, INCLUDING ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR ANY
PARTICULAR PURPOSE, NON-INFRINGEMENT AND WARRANTIES OF PERFORMANCE, AND ANY
WARRANTY THAT MIGHT OTHERWISE ARISE FROM COURSE OF DEALING OR USAGE OF TRADE.
NO WARRANTY IS EITHER EXPRESS OR IMPLIED WITH RESPECT TO THE USE OF THE
SOFTWARE OR DOCUMENTATION. Under no circumstances shall University be liable
for incidental, special, indirect, direct or consequential damages or loss of
profits, interruption of business, or related expenses which may arise from use
of Software or Documentation, including but not limited to those resulting from
defects in Software and/or Documentation, or loss or inaccuracy of data of any
kind.


 */

package galois.runtime.wl;

import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import util.fn.Lambda;
import util.fn.Lambda0;

/**
 * A class that generates worklists from a series of ordering rules.
 * 
 * <p>
 * Worklists are generated by applying a sequence of <i>ordering rules</i> that
 * determine how elements in a worklist should be ordered with respect to each
 * other. A rule <i>R(a, b)</i> is an ordering function over pairs of elements
 * <i>a, b</i> which specifies whether:
 * <ol>
 * <li><i>a</i> should appear before <i>b</i>,
 * <li><i>b</i> should appear before <i>a</i>, or
 * <li><i>a</i> and <i>b</i> have no defined order with respect to each other
 * and can be ordered arbitrarily.
 * </ol>
 * 
 * <p>
 * A sequence of rules <i>R1, R2, R3, ...</i> denotes a lexicographic order in
 * which elements that are not ordered by <i>R1</i> are ordered by <i>R2</i> and
 * elements that are not ordered by <i>R2</i> are ordered by <i>R3</i> and so
 * on.
 * 
 * <p>
 * An example: If our elements have integer priorities and <i>R1</i> orders
 * elements in ascending priority order and <i>R2</i> orders elements in
 * first-in-first-out (FIFO) order (i.e., queue order), then <i>R1, R2</i> means
 * the order where elements are processed in increasing priority order and
 * elements that have the same priority are processed in the same order they
 * were added to the worklist.
 * 
 * <p>
 * Ordering specifications are comprised of two orders: a global order and a
 * local order. The global order is applied to the initial collection of
 * elements. The local order (if present) is applied to all the elements
 * generated from processing an element from the global order. Continuing from
 * the previous example, if <i>R3</i> is last-in-first-out (LIFO) order (i.e.,
 * stack order), then the global order <i>R1, R2</i> and local order <i>R3</i>
 * means that elements are initially ordered as before, except that any new
 * elements added while processing element <i>a</i> from the global order are
 * processed first (in LIFO order) before moving on to the next element in the
 * global order.
 * 
 * <p>
 * For unordered Galois iterators, the observed execution may not always match
 * the specified order. In particular, speculative execution may result in a
 * different observed order than what was specified.
 * 
 * <p>
 * For ordered Galois iterators, only specifications that only contain
 * {@link Ordered} rules are valid.
 * 
 * <p>
 * Certain rules can only be used as the final rule in a sequence of rules.
 * These rules are marked with {@link OnlyLeaf}.
 * 
 * <p>
 * Concretely, ordering specifications are created by {@link #defaultOrder()},
 * {@link #first(Class, Object...)},
 * {@link Priority.Rule#then(Class, Object...)}, and
 * {@link Priority.Rule#thenLocally(Class, Object...)}. The previous example
 * would be:
 * <p>
 * 
 * <pre>
 *       Comparator<T> cmp = ... // ascending integer comparator
 *       Priority.first(Ordered.class, cmp).then(FIFO.class).thenLocally(LIFO.class);
 * </pre>
 * 
 * 
 */
public class Priority {
  private static <T, U> UnorderedWorklist<U> make(Rule last, boolean isSerial, boolean isOrdered, Lambda<U, T> wrapper) {
    CompiledRules compiled = new CompiledRules(last);
    // wrap first to simplify cases
    if (wrapper != null) {
      compiled.wrap(wrapper);
    }
    compiled.rewrite(isSerial);
    return compiled.gen(isOrdered);
  }

  /**
   * Creates a worklist from the ordering specification for an unordered Galois
   * iterator.
   * 
   * @param <T>
   *          the type of elements of the worklist
   * @param clz
   *          the ordering specification
   * @return a worklist matching the specification
   */
  public static <T, U> UnorderedWorklist<U> makeUnordered(Rule last, boolean isSerial, Lambda<U, T> wrapper) {
    return make(last, isSerial, false, wrapper);
  }

  /**
   * Creates a worklist from the ordering specification for an ordered Galois
   * iterator.
   * 
   * @param <T>
   *          the type of elements of the worklist
   * @param clz
   *          the ordering specification
   * @return a worklist matching the specification
   */
  public static <T> OrderedWorklist<T> makeOrdered(Rule last, boolean isSerial) {
    Worklist<T> wl = make(last, isSerial, true, null);
    if (wl instanceof OrderedWorklist) {
      return new OrderedWorklistImpl<T>((OrderedWorklist<T>) wl);
    } else {
      throw new Error("Rule does not make ordered worklist, use Ordered rules");
    }
  }

  /**
   * Creates a worklist from the ordering specification for an ordered Galois
   * iterator for use in ParaMeter.
   * 
   * @param <T>
   *          the type of elements of the worklist
   * @param rule
   *          the ordering specification
   * @return a worklist matching the specification
   */
  public static <T> ParameterOrderedWorklist<T> makeParameterOrdered(Rule rule) {
    OrderedWorklist<T> wl = makeOrdered(rule, true);
    return new ParameterOrderedWorklist<T>(wl.getComparator());
  }

  /**
   * Creates a worklist for an unordered Galois iterator for use in ParaMeter.
   * There is no need for an ordering specification in this case because the
   * default strategy for ParaMeter with unordered iterators is to randomly
   * select elements to execute.
   * 
   * @param <T>
   *          the type of elements of the worklist
   * @return a worklist matching the specification
   */
  public static <T> ParameterUnorderedWorklist<T> makeParameterUnordered() {
    return new ParameterUnorderedWorklist<T>();
  }

  /**
   * Easier representation of rules than linked list.
   */
  private static class CompiledRules {
    private final List<Rule> workGlobal;
    private final List<Rule> workLocal;
    private final List<Rule> abortedGlobal;
    private final List<Rule> abortedLocal;

    public CompiledRules(Rule last) {
      this();
      List<Rule> work = new ArrayList<Rule>();
      List<Rule> aborted = new ArrayList<Rule>();
      
      splitWorkAborted(last, work, aborted);
      splitGlobalLocal(work, workGlobal, workLocal);
      splitGlobalLocal(aborted, abortedGlobal, abortedLocal);
    }

    private CompiledRules() {
      workGlobal = new ArrayList<Rule>();
      workLocal = new ArrayList<Rule>();
      abortedGlobal = new ArrayList<Rule>();
      abortedLocal = new ArrayList<Rule>();
    }

    public void rewrite(boolean isSerial) {
      rewrite(workGlobal, workLocal, isSerial);
      rewrite(abortedGlobal, abortedLocal, isSerial);
    }

    public <T, U> void wrap(Lambda<U, T> wrapper) {
      for (List<Rule> rules : new List[] {workGlobal, workLocal, abortedGlobal, abortedLocal }) {
        for (Rule rule : rules) {
          FunctionParameter anno = rule.clz.getAnnotation(FunctionParameter.class);
          if (anno != null) {
            FunctionParameterType type = anno.value();
            int pos = type.getPosition();
            
            rule.args[pos] = type.compose(wrapper, rule.args[pos]);
          }
        }
      }
    }

    public <T> UnorderedWorklist<T> gen(boolean isOrdered) {
      Lambda0<Worklist<T>> workGlobalWl = gen(workGlobal);
      Lambda0<Worklist<T>> workLocalWl = gen(workLocal);
      Lambda0<Worklist<T>> abortedGlobalWl = gen(abortedGlobal);
      Lambda0<Worklist<T>> abortedLocalWl = gen(abortedLocal);

      if (workGlobalWl == null && workLocalWl == null)
        throw new Error("Empty specification for worklist");

      if (isOrdered) {
        if (workLocalWl != null || abortedGlobalWl != null || abortedLocalWl != null)
          throw new Error("Cannot use aborted or local clauses in ordered specification");
        return (UnorderedWorklist<T>) workGlobalWl.call();
      }

      if (abortedGlobalWl != null && abortedLocalWl != null)
        throw new Error("Cannot use both global and local parts for aborted specification");

      return new UnorderedWorklistImpl<T>(workGlobalWl, workLocalWl, abortedGlobalWl, abortedLocalWl);
    }

    private static List<Rule> collectRules(Rule last) {
      List<Rule> rules = new ArrayList<Rule>();
      for (Rule rule = last; rule != null; rule = rule.prev) {
        if (rule.clz != null)
          rules.add(rule.copy());
      }
      Collections.reverse(rules);
      return rules;
    }
    
    private static void splitWorkAborted(Rule last, List<Rule> work, List<Rule> aborted) {
      boolean found = false;
      for (Rule rule = last; rule != null; rule = rule.prev) {
        if (rule.abortedRule != null) {
          if (found) {
            throw new Error("Multiple aborted order specifications");
          } else {
            found = true;
            aborted.addAll(collectRules(rule.abortedRule));
          }
        }
      }
      work.addAll(collectRules(last));
    }

    private static void splitGlobalLocal(List<Rule> all, List<Rule> global, List<Rule> local) {
      boolean inLocal = false;
      for (Rule rule : all) {
        if (rule.isLocalRule || inLocal) {
          inLocal = true;
          local.add(rule);
        } else {
          global.add(rule);
        }
      }
    }

    private static Constructor<?> getMatchingConstructor(Rule rule, Class<?> clz, int numArgs) {
      for (final Constructor<?> c : clz.getConstructors()) {
        Class<?>[] params = c.getParameterTypes();

        if (params.length == numArgs) {
          return c;
        }
      }
      throw new Error("Couldn't find matching constructor for " + rule + " with " + numArgs + " args ");
    }

    private static <T> Lambda0<Worklist<T>> gen(List<Rule> rules) {
      Lambda0<Worklist<T>> maker = null;
      for (int i = rules.size() - 1; i >= 0; i--) {
        Rule rule = rules.get(i);
        // for maker and needSize arguments
        int numArgs = rule.args.length + 2;
        final Constructor<?> constructor = getMatchingConstructor(rule, rule.clz, numArgs);

        final Object[] actuals = new Object[numArgs];
        System.arraycopy(rule.args, 0, actuals, 0, rule.args.length);

        // Add hidden parameters
        actuals[rule.args.length] = maker;
        actuals[rule.args.length + 1] = rule.needSize;

        maker = new Lambda0<Worklist<T>>() {
          @SuppressWarnings("unchecked")
          @Override
          public Worklist<T> call() {
            try {
              return (Worklist<T>) constructor.newInstance(actuals);
            } catch (Exception e) {
              throw new Error(e);
            }
          }
        };
      }
      return maker;
    }

    private static void rewrite(List<Rule> global, List<Rule> local, boolean isSerial) {
      rewrite(global, isSerial);
      rewrite(local, true);
    }

    private static void rewrite(List<Rule> rules, boolean isSerial) {
      rewriteNeedSize(rules);
      rewriteLeaf(rules);
      rewriteBounded(rules);
      rewriteSerial(rules, isSerial); // last to simplify cases
    }

    private static void rewriteNeedSize(List<Rule> rules) {
      for (int i = 1; i < rules.size(); i++) {
        if (rules.get(i - 1).clz.isAnnotationPresent(NeedsSize.class))
          rules.get(i).needSize = true;
      }
    }

    private static void rewriteLeaf(List<Rule> rules) {
      if (rules.isEmpty())
        return;

      Rule last = rules.get(rules.size() - 1);
      for (Rule rule : rules) {
        if (rule != last && rule.clz.isAnnotationPresent(OnlyLeaf.class))
          throw new Error("Leaf rule used in non-leaf position: " + rule);
      }
      MatchingLeafVersion leaf = last.clz.getAnnotation(MatchingLeafVersion.class);
      if (leaf != null) {
        last.clz = leaf.value();
      }
    }

    private static void rewriteBounded(List<Rule> rules) {
      for (int i = 1; i < rules.size(); i++) {
        Rule prev = rules.get(i - 1);
        Rule rule = rules.get(i);
        if (prev.clz == ChunkedFIFO.class || prev.clz == ChunkedLIFO.class) {
          if (rule.clz == FIFO.class || rule.clz == BoundedFIFO.class) {
            rule.clz = BoundedFIFO.class;
            rule.args = prev.args;
          } else if (rule.clz == LIFO.class || rule.clz == BoundedLIFO.class) {
            rule.clz = BoundedLIFO.class;
            rule.args = prev.args;
          }
        }
      }
    }

    private static void rewriteSerial(List<Rule> rules, boolean isSerial) {
      for (Rule rule : rules) {
        if (!isSerial) {
          rule.clz = rule.clz.getAnnotation(MatchingConcurrentVersion.class).value();
        }
        if (rule.clz.isAnnotationPresent(NestedAreSerial.class)) {
          isSerial = true;
        }
      }
    }
  }

  /**
   * An ordering specification. An ordering specification consists of two parts:
   * a global order and a local order. An order is a sequence of rules chained
   * together by a sequence of {@link #then(Class, Object...)} methods. The
   * first order in an ordering specification is the global order. The
   * {@link #thenLocally(Class, Object...)} method marks the end of the global
   * order and the beginning of the local order.
   * 
   * 
   */
  public static class Rule {
    private static Object[] emptyArgs = new Object[0];
    private Rule prev;
    private Rule next;
    private Rule abortedRule;

    private Class<?> clz;
    private Object[] args;
    private boolean isLocalRule;
    private boolean needSize;

    private Rule() {
      args = emptyArgs;
    }

    /**
     * Returns a shallow copy of the rule (i.e., without copies of Rule fields).
     * 
     * @return
     */
    private Rule copy() {
      Rule retval = new Rule();
      retval.prev = prev;
      retval.next = next;
      retval.abortedRule = abortedRule;
      retval.clz = clz;
      retval.args = Arrays.copyOf(args, args.length);
      retval.isLocalRule = isLocalRule;
      retval.needSize = needSize;
      return retval;
    }

    /**
     * Appends a rule to the current order. Valid arguments to a rule are the
     * same as the arguments to the constructor of each rule class excluding the
     * <code>maker</code> and <code>needSize</code> arguments, which are used
     * internally by the construction algorithm to generate worklists.
     * 
     * <p>
     * Thus, if rule <i>R1</i> has two constructors
     * <code>R1(Maker&lt;T&gt; maker, int needSize)</code> and
     * <code>R1(int size, Maker&lt;T&gt; maker, int needSize)</code>, then there
     * are only two valid calls to this method with <i>R1</i>:
     * <code>then(R1)</code> and <code>then(R1, int)</code>.
     * 
     * @param clz
     *          class of the rule to append
     * @param args
     *          the arguments to the rule if any
     * @return a reference to the updated order
     * @see #thenLocally(Class, Object...)
     * @see Priority#first(Class, Object...)
     */
    @SuppressWarnings("rawtypes")
    public Rule then(Class<? extends Worklist> clz, Object... args) {
      this.clz = clz;
      this.args = args;
      next = new Rule();
      next.prev = this;
      return next;
    }

    public Rule withRuleForAborted(Rule rule) {
      this.abortedRule = rule;
      return this;
    }

    /**
     * Appends a rule, marks the rule and all subsequent rules as belonging to
     * the local order.
     * 
     * <p>
     * This method follows the same convention regarding arguments to rules as
     * {@link #then(Class, Object...)}.
     * 
     * @param rule
     *          the rule to append
     * @param args
     *          the arguments to the rule if any
     * @return a reference to the updated order
     * @see #then(Class, Object...)
     */
    @SuppressWarnings("rawtypes")
    public Rule thenLocally(Class<? extends Worklist> rule, Object... args) {
      this.isLocalRule = true;
      return then(rule, args);
    }

    @Override
    public String toString() {
      return clz == null ? "(null)" : String.format("%s(%s)", clz.getName(), Arrays.toString(args));
    }

    public void toString(StringBuilder sb) {
      for (Rule cur = this; cur != null && cur.next != null; cur = cur.next) {
        sb.append(cur.toString());
      }
    }
  }

  /**
   * Returns a default order suitable for many unordered iterators that balances
   * locality, synchronization overheads, and load balancing.
   * 
   * @return a default order
   */
  public static Rule defaultOrder() {
    return first(ChunkedFIFO.class);
  }

  /**
   * Initializes a new ordering specification with the given first rule.
   * Additional rules can be appended with
   * {@link Priority.Rule#then(Class, Object...)}.
   * 
   * @param rule
   *          the rule to append
   * @param args
   *          arguments to the rule if any
   * @return a reference to the updated order
   * @see Priority.Rule#then(Class, Object...)
   */
  @SuppressWarnings("rawtypes")
  public static Rule first(Class<? extends Worklist> rule, Object... args) {
    return new Rule().then(rule, args);
  }
  
  public static Rule empty() {
    return new Rule();
  }
}
